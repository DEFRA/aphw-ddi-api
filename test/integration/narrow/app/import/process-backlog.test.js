jest.mock('../../../../../app/import/backlog-functions')
const { buildDog, buildPerson, warmUpCache, validateAndInsertPerson, validateAndInsertDog, getBacklogRows } = require('../../../../../app/import/backlog-functions')
jest.mock('../../../../../app/lib/db-functions')
const { dbLogErrorToBacklog } = require('../../../../../app/lib/db-functions')
jest.mock('../../../../../app/lookups')
const { getMicrochipType } = require('../../../../../app/lookups')
const { testBacklogPerson } = require('./persons')
const { testBacklogDog } = require('./dogs')
const backlogRows = require('./mock-backlog-rows')
const { process } = require('../../../../../app/import/process-backlog')

describe('ProcessBacklog test', () => {
  test('Should return zero stats when no rows', async () => {
    getMicrochipType.mockResolvedValue({ id: 9 })
    warmUpCache.mockResolvedValue(null)
    buildPerson.mockReturnValue(testBacklogPerson)
    validateAndInsertPerson.mockResolvedValue('REF1')
    buildDog.mockResolvedValue(testBacklogDog)
    validateAndInsertDog.mockResolvedValue(true)
    dbLogErrorToBacklog.mockResolvedValue()
    getBacklogRows.mockResolvedValue([])
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(0)
    expect(res.rowsInError).toBe(0)
  })

  test('Should return zero stats when no rows', async () => {
    getMicrochipType.mockResolvedValue({ id: 9 })
    warmUpCache.mockResolvedValue()
    buildPerson.mockReturnValue(testBacklogPerson)
    validateAndInsertPerson.mockResolvedValue('REF1')
    buildDog.mockResolvedValue(testBacklogDog)
    validateAndInsertDog.mockResolvedValue()
    dbLogErrorToBacklog.mockResolvedValue()
    getBacklogRows.mockResolvedValue([])
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(0)
    expect(res.rowsInError).toBe(0)
  })

  test('Main loop should run without errors', async () => {
    getMicrochipType.mockResolvedValue({ id: 9 })
    warmUpCache.mockResolvedValue(null)
    buildPerson.mockReturnValue(testBacklogPerson)
    validateAndInsertPerson.mockResolvedValue('REF1')
    buildDog.mockResolvedValue(testBacklogDog)
    validateAndInsertDog.mockResolvedValue(true)
    dbLogErrorToBacklog.mockResolvedValue()
    getBacklogRows.mockResolvedValue(backlogRows)
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(2)
    expect(res.rowsInError).toBe(0)
    expect(res.dogRowsIntoDb).toBe(2)
  })

  test('Should log error when inserting invalid dog', async () => {
    getMicrochipType.mockResolvedValue({ id: 9 })
    warmUpCache.mockResolvedValue(null)
    buildPerson.mockReturnValue(testBacklogPerson)
    validateAndInsertPerson.mockResolvedValue('REF1')
    buildDog.mockResolvedValue(testBacklogDog)
    validateAndInsertDog.mockResolvedValue(false)
    dbLogErrorToBacklog.mockResolvedValue()
    getBacklogRows.mockResolvedValue(backlogRows)
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(2)
    expect(res.rowsInError).toBe(2)
    expect(res.dogRowsIntoDb).toBe(0)
  })

  test('Should log error when inserting invalid person', async () => {
    getMicrochipType.mockResolvedValue({ id: 9 })
    warmUpCache.mockResolvedValue(null)
    buildPerson.mockReturnValue(testBacklogPerson)
    validateAndInsertPerson.mockResolvedValue(null)
    buildDog.mockResolvedValue(testBacklogDog)
    validateAndInsertDog.mockResolvedValue(true)
    dbLogErrorToBacklog.mockResolvedValue()
    getBacklogRows.mockResolvedValue(backlogRows)
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(2)
    expect(res.rowsInError).toBe(2)
    expect(res.dogRowsIntoDb).toBe(0)
  })

  test('Should log error when exception thrown', async () => {
    getMicrochipType.mockResolvedValue({ id: 9 })
    warmUpCache.mockResolvedValue(null)
    buildPerson.mockImplementation(() => { throw new Error('dummy error') })
    validateAndInsertPerson.mockResolvedValue('REF1')
    buildDog.mockResolvedValue(testBacklogDog)
    validateAndInsertDog.mockResolvedValue(true)
    dbLogErrorToBacklog.mockResolvedValue()
    getBacklogRows.mockResolvedValue(backlogRows)
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(2)
    expect(res.rowsInError).toBe(2)
    expect(res.dogRowsIntoDb).toBe(0)
  })
})
