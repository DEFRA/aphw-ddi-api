const { buildDog, buildPerson, warmUpCache, validateAndInsertPerson, validateAndInsertDog, getBacklogRows } = require('../../../../../app/import/backlog-functions')
jest.mock('../../../../../app/import/backlog-functions')
const { dbLogErrorToBacklog } = require('../../../../../app/lib/db-functions')
jest.mock('../../../../../app/lib/db-functions')
const { getMicrochipType } = require('../../../../../app/lookups')
jest.mock('../../../../../app/lookups')
const { testBacklogPerson } = require('./persons')
const { testBacklogDog } = require('./dogs')
const backlogRows = require('./mock-backlog-rows')
const { process } = require('../../../../../app/import/process-backlog')

describe('ProcessBacklog test', () => {
  test('Should return zero stats when no rows', async () => {
    getMicrochipType.mockImplementation(() => Promise.resolve({ id: 9 }))
    warmUpCache.mockImplementation(() => Promise.resolve(null))
    buildPerson.mockImplementation(() => testBacklogPerson)
    validateAndInsertPerson.mockImplementation(() => Promise.resolve('REF1'))
    buildDog.mockImplementation(() => testBacklogDog)
    validateAndInsertDog.mockImplementation(() => Promise.resolve())
    dbLogErrorToBacklog.mockImplementation(() => Promise.resolve())
    getBacklogRows.mockImplementation(() => Promise.resolve([]))
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(0)
    expect(res.rowsInError).toBe(0)
  })

  test('Main loop should run without errors', async () => {
    getMicrochipType.mockImplementation(() => Promise.resolve({ id: 9 }))
    warmUpCache.mockImplementation(() => Promise.resolve(null))
    buildPerson.mockImplementation(() => testBacklogPerson)
    validateAndInsertPerson.mockImplementation(() => Promise.resolve('REF1'))
    buildDog.mockImplementation(() => testBacklogDog)
    validateAndInsertDog.mockImplementation(() => Promise.resolve(true))
    dbLogErrorToBacklog.mockImplementation(() => Promise.resolve())
    getBacklogRows.mockImplementation(() => Promise.resolve(backlogRows))
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(2)
    expect(res.rowsInError).toBe(0)
    expect(res.dogRowsIntoDb).toBe(2)
  })

  test('Should log error when inserting invalid dog', async () => {
    getMicrochipType.mockImplementation(() => Promise.resolve({ id: 9 }))
    warmUpCache.mockImplementation(() => Promise.resolve(null))
    buildPerson.mockImplementation(() => testBacklogPerson)
    validateAndInsertPerson.mockImplementation(() => Promise.resolve('REF1'))
    buildDog.mockImplementation(() => testBacklogDog)
    validateAndInsertDog.mockImplementation(() => Promise.resolve(false))
    dbLogErrorToBacklog.mockImplementation(() => Promise.resolve())
    getBacklogRows.mockImplementation(() => Promise.resolve(backlogRows))
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(2)
    expect(res.rowsInError).toBe(2)
    expect(res.dogRowsIntoDb).toBe(0)
  })

  test('Should log error when inserting invalid person', async () => {
    getMicrochipType.mockImplementation(() => Promise.resolve({ id: 9 }))
    warmUpCache.mockImplementation(() => Promise.resolve(null))
    buildPerson.mockImplementation(() => testBacklogPerson)
    validateAndInsertPerson.mockImplementation(() => Promise.resolve(null))
    buildDog.mockImplementation(() => testBacklogDog)
    validateAndInsertDog.mockImplementation(() => Promise.resolve(true))
    dbLogErrorToBacklog.mockImplementation(() => Promise.resolve())
    getBacklogRows.mockImplementation(() => Promise.resolve(backlogRows))
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(2)
    expect(res.rowsInError).toBe(2)
    expect(res.dogRowsIntoDb).toBe(0)
  })

  test('Should log error when exception thrown', async () => {
    getMicrochipType.mockImplementation(() => Promise.resolve({ id: 9 }))
    warmUpCache.mockImplementation(() => Promise.resolve(null))
    buildPerson.mockImplementation(() => { throw new Error('dummy error') })
    validateAndInsertPerson.mockImplementation(() => Promise.resolve('REF1'))
    buildDog.mockImplementation(() => testBacklogDog)
    validateAndInsertDog.mockImplementation(() => Promise.resolve(true))
    dbLogErrorToBacklog.mockImplementation(() => Promise.resolve())
    getBacklogRows.mockImplementation(() => Promise.resolve(backlogRows))
    const res = await process({})
    expect(res).not.toBe(null)
    expect(res.rowsProcessed).toBe(2)
    expect(res.rowsInError).toBe(2)
    expect(res.dogRowsIntoDb).toBe(0)
  })
})
